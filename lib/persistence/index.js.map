{"version":3,"sources":["../../src/persistence/index.js"],"names":["DEFAULT_GRACE","redisFactory","doNotPersist","keySpace","grace","bootload","cacheInstance","redisClient","cacheKeyPrefix","name","persisting","get","args","next","pop","then","obj","key","cache","test","redisKey","log","debug","objWithMeta","set","JSON","stringify","Math","round","TTL","err","warn","del","clear","load","Date","now","mapLoaded","Object","keys","map","info","length","extraData","onDispose","catch","error","addDisposer","destroy","removeDisposer"],"mappings":";;;;;;kQAAA;;;;;AAGA;;AAQA;;;;;;AAEA,MAAMA,gBAAgB,KAAK,EAAL,GAAU,EAAV,GAAe,IAArC;;AAEA;;;;;;;;;kBAQe,CAACC,YAAD,EACb;AACEC,iBAAe,IADjB;AAEEC,aAAW,EAFb;AAGEC,UAAQJ,aAHV;AAIEK,aAAW;AAJb,IAKI,EANS,KAOTC,aAAD,IAAmB;AACtB,QAAMC,cAAcN,cAApB;AACA,QAAMO,iBAAkB,GAAE,kBAAIC,IAAK,IAAGN,QAAS,EAA/C;AACA,QAAMO,aAAa,EAAnB;;AAEA,QAAMC,MAAM,CAAC,GAAGC,IAAJ,KAAa;AACvB,UAAMC,OAAOD,KAAKE,GAAL,EAAb;AACA,WAAOD,KAAK,GAAGD,IAAR,EAAcG,IAAd,CAAoBC,GAAD,IAAS;AACjC,YAAM,CAACC,GAAD,IAAQL,IAAd;AACA,UAAII,IAAIE,KAAJ,KAAc,MAAlB,EAA0B;AACxB,YAAI,CAAC,CAAChB,YAAD,IAAiB,CAACA,aAAaiB,IAAb,CAAkBF,GAAlB,CAAnB,KAA8C,wCAAeD,GAAf,CAA9C,IAAqE,CAACN,WAAWO,GAAX,CAA1E,EAA2F;AACzFP,qBAAWO,GAAX,IAAkB,IAAlB;AACA,gBAAMG,WAAW,qCAAYZ,cAAZ,EAA4BS,GAA5B,CAAjB;AACAX,wBAAce,GAAd,CAAkBC,KAAlB,CAAyB,mBAAkBF,QAAS,GAApD;AACA,gBAAMG,cAAcjB,cAAcK,GAAd,CAAkBM,GAAlB,CAApB;AACAV,sBAAYiB,GAAZ,CAAgBJ,QAAhB,EAA0BK,KAAKC,SAAL,CAAeH,WAAf,CAA1B,EAAuD,IAAvD,EAA6DI,KAAKC,KAAL,CAAW,CAACL,YAAYM,GAAZ,GAAkBzB,KAAnB,IAA4B,IAAvC,CAA7D,EAA4G0B,GAAD,IAAS;AAClH,gBAAIA,GAAJ,EAAS;AACPxB,4BAAce,GAAd,CAAkBU,IAAlB,CAAuBD,GAAvB;AACD;AACD,mBAAOpB,WAAWO,GAAX,CAAP;AACD,WALD;AAMD,SAXD,MAWO;AACLX,wBAAce,GAAd,CAAkBC,KAAlB,CAAyB,oDAAmDL,GAAI,EAAhF;AACD;AACF;AACD,aAAOD,GAAP;AACD,KAnBM,CAAP;AAoBD,GAtBD;;AAwBA,QAAMgB,MAAM,CAACf,GAAD,EAAMJ,IAAN,KAAe;AACzB,WAAO,mCAAU,qCAAYL,cAAZ,EAA4BS,GAA5B,CAAV,EAA4CV,WAA5C,EAAyDQ,IAAzD,CAA8D,MAAM;AACzEF,WAAKI,GAAL;AACD,KAFM,CAAP;AAGD,GAJD;;AAMA,QAAMgB,QAASpB,IAAD,IAAU;AACtB,WAAO,oCAAWL,cAAX,EAA2BD,WAA3B,EAAwCQ,IAAxC,CAA6C,MAAM;AACxDF;AACD,KAFM,CAAP;AAGD,GAJD;;AAMA,QAAMqB,OAAO,MAAM;AACjB,UAAMnB,OAAOoB,KAAKC,GAAL,EAAb;AACA,WAAO,qCAAY5B,cAAZ,EAA4BD,WAA5B,EAAyCD,cAAce,GAAvD,EACJN,IADI,CACEsB,SAAD,IAAe;AACnBC,aAAOC,IAAP,CAAYF,SAAZ,EAAuBG,GAAvB,CAA4BvB,GAAD,IAAS;AAClCX,sBAAcY,KAAd,CAAoBM,GAApB,CAAwB,6CAAoBhB,cAApB,EAAoCS,GAApC,CAAxB,EAAkEoB,UAAUpB,GAAV,CAAlE;AACA,eAAOA,GAAP;AACD,OAHD;AAIAX,oBAAce,GAAd,CAAkBoB,IAAlB,CAAwB,QAAOH,OAAOC,IAAP,CAAYF,SAAZ,EAAuBK,MAAO,0BAAyBP,KAAKC,GAAL,KAAarB,IAAK,KAAxG;AACD,KAPI,CAAP;AAQD,GAVD;;AAYA,QAAMO,QAAQ,CAACqB,SAAD,EAAY9B,IAAZ,KAAqB;AACjC,WAAOA,gBAAML,cAAN,IAAyBmC,SAAzB,EAAP;AACD,GAFD;;AAIA,QAAMC,YAAa3B,GAAD,IAAS;AACzB,uCAAU,qCAAYT,cAAZ,EAA4BS,GAA5B,CAAV,EAA4CV,WAA5C,EAAyDQ,IAAzD,CAA8D,MAAM;AAClET,oBAAce,GAAd,CAAkBC,KAAlB,CAAyB,gBAAeL,GAAI,oCAA5C;AACD,KAFD,EAEG4B,KAFH,CAEUf,GAAD,IAAS;AAChBxB,oBAAce,GAAd,CAAkByB,KAAlB,CAAwBhB,GAAxB;AACD,KAJD;AAKD,GAND;;AAQAxB,gBAAcyC,WAAd,CAA0BH,SAA1B;;AAEA,QAAMI,UAAU,MAAM;AACpB1C,kBAAc2C,cAAd,CAA6BL,SAA7B;AACD,GAFD;;AAIA,MAAIvC,QAAJ,EAAc;AACZ6B,WAAOW,KAAP,CAAavC,cAAce,GAAd,CAAkByB,KAA/B;AACD;;AAED,SAAO;AACLnC,OADK;AAELqB,OAFK;AAGLC,SAHK;AAILC,QAJK;AAKLZ,SALK;AAML0B;AANK,GAAP;AAQD,C","file":"index.js","sourcesContent":["/**\n * @module\n **/\nimport {\n  loadObjects,\n  deleteKey,\n  deleteKeys,\n  extractKeyFromRedis,\n  getRedisKey,\n  isSerializable\n} from './persistence-helpers.js'\nimport pkg from '../../package.json'\n\nconst DEFAULT_GRACE = 60 * 60 * 24 * 1000\n\n/**\n * @description Create new persistentCache middleware instance to be used by inMemoryCache\n * @param {function} redisFactory - provides a redisClient with publish/subscribe features\n * @param {RegExp} options.doNotPersist - regexp-matching of keys that are not to peristed\n * @param {String} options.keySpace - Prefix to use for keys in redis\n * @param {number} options.expire - Keys stored in redis expire in seconds\n * @returns {Object} middleware facade\n **/\nexport default (redisFactory,\n  {\n    doNotPersist = null,\n    keySpace = '',\n    grace = DEFAULT_GRACE,\n    bootload = true\n  } = {}\n) => (cacheInstance) => {\n  const redisClient = redisFactory()\n  const cacheKeyPrefix = `${pkg.name}-${keySpace}`\n  const persisting = {}\n\n  const get = (...args) => {\n    const next = args.pop()\n    return next(...args).then((obj) => {\n      const [key] = args\n      if (obj.cache === 'miss') {\n        if ((!doNotPersist || !doNotPersist.test(key)) && isSerializable(obj) && !persisting[key]) {\n          persisting[key] = true\n          const redisKey = getRedisKey(cacheKeyPrefix, key)\n          cacheInstance.log.debug(`Persist to key \"${redisKey}\"`)\n          const objWithMeta = cacheInstance.get(key)\n          redisClient.set(redisKey, JSON.stringify(objWithMeta), 'ex', Math.round((objWithMeta.TTL + grace) / 1000), (err) => {\n            if (err) {\n              cacheInstance.log.warn(err)\n            }\n            delete persisting[key]\n          })\n        } else {\n          cacheInstance.log.debug(`skipping persistence of promised object with key ${key}`)\n        }\n      }\n      return obj\n    })\n  }\n\n  const del = (key, next) => {\n    return deleteKey(getRedisKey(cacheKeyPrefix, key), redisClient).then(() => {\n      next(key)\n    })\n  }\n\n  const clear = (next) => {\n    return deleteKeys(cacheKeyPrefix, redisClient).then(() => {\n      next()\n    })\n  }\n\n  const load = () => {\n    const then = Date.now()\n    return loadObjects(cacheKeyPrefix, redisClient, cacheInstance.log)\n      .then((mapLoaded) => {\n        Object.keys(mapLoaded).map((key) => {\n          cacheInstance.cache.set(extractKeyFromRedis(cacheKeyPrefix, key), mapLoaded[key])\n          return key\n        })\n        cacheInstance.log.info(`Read ${Object.keys(mapLoaded).length} keys from redis. Used ${Date.now() - then} ms`)\n      })\n  }\n\n  const debug = (extraData, next) => {\n    return next({cacheKeyPrefix, ...extraData})\n  }\n\n  const onDispose = (key) => {\n    deleteKey(getRedisKey(cacheKeyPrefix, key), redisClient).then(() => {\n      cacheInstance.log.debug(`deleting key ${key} from redis (evicted by lru-cache)`)\n    }).catch((err) => {\n      cacheInstance.log.error(err)\n    })\n  }\n\n  cacheInstance.addDisposer(onDispose)\n\n  const destroy = () => {\n    cacheInstance.removeDisposer(onDispose)\n  }\n\n  if (bootload) {\n    load().catch(cacheInstance.log.error)\n  }\n\n  return {\n    get,\n    del,\n    clear,\n    load,\n    debug,\n    destroy\n  }\n}\n"]}